## Хранилище Счетчиков
### Мотивация
Это мой первый проект на Go, его смысл в том, чтобы потренироваться:
* Организовывать код проекта согласно [чистой архитектуре](https://github.com/evrone/go-clean-template)
* Использовать **каналы** для синхронизации доступа к общим данным
* Использовать **инъекцию зависимостей** для обеспечения низкой связанности слоев
* Использовать модуль [BurntSushi/toml](https://github.com/BurntSushi/toml) для **конфигурирования** приложения из `.toml` файла
  * Путь к файлу можно передать с **флагом** `-config-path` при запуске исполняемого файла приложения
* Использовать модуль [stretchr/testify](https://github.com/stretchr/testify) для **модульного тестирования (unit-tests)** функций-обработчиков HTTP сервера
* Проводить **нагрузочное тестирование** с помощью утилиты [Apache JMeter](https://jmeter.apache.org/index.html)

### Описание
Проект представляет из себя REST API сервер, который реализует **хранилище счетчиков**. В терминологии Go, это map'а, то есть набор из ключей (названий счетчиков) и их текущих значений.

Пользователям доступны следующие функции:
1. Создание счетчика по запросу: `/set?name=<имя>&val=<число>`
2. Просмотр текущего состояния счетчика по запросу: `/get?name=<имя>`
3. Увеличение счетчика на 1 по запросу: `/inc?name=<имя>`
4. Уменьшение счетчика на 1 по запросу: `/dec?name=<имя>`

## Сервер
### Алгоритм работы
Для обеспечения безопасного одновременного доступа обработчиков к данным можно использовать каналы или мьютексы. В данном проекте использовались каналы.

Обработчики запросов формируют команды и отправляют их в канал `cmds`.

Горутина, работающая в фоновом режиме, считывает команды из канала `cmds` и вызывает соответствующий `UseCase`, который в свою очередь вызывает соответствующий метод хранилища счетчиков `CounterStore`.

Метод хранилища счетчиков `CounterStore` возвращает ответ, который проходит через `UseCase` и попадает в горутину, которая отправляет его по каналу `replyChan`, которым обладает каждая команда.

Обработчики считывают информацию из `replyChan` и формируют ответ на запрос пользователя.

Данный алгоритм взаимодействия слоев соответствует идеологии чистой архитектуры:

```
HTTP > usecase
        usecase > repository
        usecase < repository
HTTP < usecase
```

### Архитектура
<p align="center">
  <img src="/assets/architecture.png" width="800">
</p>

## REST API
### Пример использования
```bash
$ curl "localhost:8080/set?name=a&val=19"
counter 'a' with val '19' was set
$ curl "localhost:8080/get?name=a"
'a': 19
$ curl "localhost:8080/inc?name=a"
ok, 'a': 20
$ curl "localhost:8080/get?name=a"
'a': 20
$ curl "localhost:8080/dec?name=a"
ok, 'a': 19
```

## Тестирование параллельных подключений
Для имитации множества [одновременных подключений](https://www.blazemeter.com/blog/jmeter-timer) можно использовать **JMeter** (аналог ApacheBench) - программу для тестирования веб-сервера.

С помощью утилиты `jmeter` создается файл `load_test.jmx`, который содержит описание нагрузочного теста (Test Plan).

* `2000` - общее число запросов (по `500` на каждый endpoint)
* `50` - число запросов, отправляемых одновременно

При проведении тестирования утилита запускается в режиме non-gui:

```bash
jmeter -n -t test-file -l results-file -j log_file
```
* `-n` - запустить программу без графического интерфейса
* `-t` - `.jmx` файл с описанием теста (Test Plan)
* `-l` - `.jtl` файл, в который будут записаны результаты отправки каждого запроса
* `-j` - `.log` файл, в который будут записаны логи

Из файла с логами можно **сгенерировать** полный отчет (dashboard) результатов нагрузочного теста:

```bash
jmeter -g result.jtl -f -o report_dir
```

* `-o` - директория, в которую будет сводный отчет с графиками и таблицами
  * директория не должна существовать или должна быть пустой
* `-f` - удалить существующий отчет

Итого, используются следующие команды:

```bash
jmeter -n -t tests/jmeter/load_test.jmx -f -l tests/jmeter/result.jtl -j tests/jmeter/result.log
jmeter -g tests/jmeter/result.jtl -f -o tests/jmeter/report
```

Тест успешно пройден, **сгенерированный отчет** появится в директории `tests/jmeter/report` в виде html-страницы:

<p align="center">
  <img src="/assets/jmeter_report.png" width="800">
</p>

## Запуск и отладка
Все команды, используемые в процессе разработки и тестирования, фиксировались в **Makefile**. 

## Полезные ссылки
* [On concurrency in Go HTTP servers](https://eli.thegreenplace.net/2019/on-concurrency-in-go-http-servers/)
* [Разработка REST-серверов на Go. Часть 1: стандартная библиотека](https://habr.com/ru/companies/ruvds/articles/559816/)
* [REST API на Golang](https://www.youtube.com/playlist?list=PLehOyJfJkFkJ5m37b4oWh783yzVlHdnUH)
* [Тестирование HTTP-сервера в Golang](https://www.youtube.com/watch?v=_OnKZr1aZHw)